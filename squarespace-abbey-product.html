<!-- 
    360Â° IMAGE ROTATOR - ABBEY PRODUCT
    Copy-paste this entire file into a Squarespace Code Block.
-->

<style>
    /* Wrapper for each instance */
    .rotator-wrap-embed {
        margin: 20px 0;
    }

    /* Container */
    .rotator-360-embed {
        position: relative;
        width: 100%;
        padding-bottom: 75%; /* 4:3; change to 56.25% for 16:9, 100% for square */
        background: #fff;
        border-radius: 10px;
        overflow: hidden;
        cursor: grab;
        user-select: none;
        touch-action: none;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        margin-bottom: 10px;
    }
    .rotator-360-embed:active { cursor: grabbing; }

    .rotator-360-embed img {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        object-fit: contain;
        display: block;
        transition: opacity 0.1s ease, transform 0.2s ease;
        will-change: opacity, transform;
        transform-origin: center center;
    }

    .rotator-overlay-embed {
        position: absolute;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        background: rgba(255, 255, 255, 0.92);
        z-index: 10;
        transition: opacity 0.3s ease;
    }
    .rotator-overlay-embed.hidden {
        opacity: 0;
        pointer-events: none;
    }
    .loading-indicator-embed {
        font-size: 1.1em;
        color: #667eea;
        font-weight: 600;
        letter-spacing: .3px;
    }

    /* Fullscreen styles */
    .rotator-360-embed.fullscreen {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        padding-bottom: 0;
        z-index: 9999;
        border-radius: 0;
        margin: 0;
    }

</style>

<div class="rotator-wrap-embed rotator-abbey" aria-label="360 degree product viewer">
    <div class="rotator-360-embed">
        <img class="rotatorImage-embed" src="" alt="360 Product View - Abbey">
        <div class="rotator-overlay-embed">
            <div class="loading-indicator-embed">Loading...</div>
        </div>
    </div>
</div>

<script>
(function() {
    'use strict';

    class Rotator360Embed {
        constructor(rootEl, options) {
            this.rootEl = rootEl;
            this.frameUrls = Array.isArray(options.frameUrls) ? options.frameUrls.filter(Boolean) : null;
            this.usesFrameUrls = Array.isArray(this.frameUrls) && this.frameUrls.length > 0;
            this.imagePath = options.imagePath || 'images/product';
            this.imageFormat = options.imageFormat || 'jpg';
            this.framePadding = options.framePadding || 3;
            this.useUnderscore = options.useUnderscore !== undefined ? options.useUnderscore : true;
            this.totalFrames = this.usesFrameUrls ? (options.totalFrames || this.frameUrls.length) : (options.totalFrames || 36);
            this.startFrame = options.startFrame !== undefined ? options.startFrame : (this.usesFrameUrls ? 0 : 1);

            this.autoRotateSpeed = options.autoRotateSpeed || 0.5;

            this.container = this.rootEl.querySelector('.rotator-360-embed');
            this.imageElement = this.container ? this.container.querySelector('.rotatorImage-embed') : null;
            this.overlay = this.container ? this.container.querySelector('.rotator-overlay-embed') : null;
            this.currentFrame = this.startFrame;

            this.isDragging = false;
            this.startX = 0;
            this.lastX = 0;
            this.rotation = 0;
            this.images = [];

            this.autoRotateInterval = null;
            this.velocityX = 0;
            this.lastMoveTs = 0;
            this.momentumId = 0;

            this.zoomLevel = 1;
            this.minZoom = 0.5;
            this.maxZoom = 3;
            this.panX = 0;
            this.panY = 0;
            this.isPanning = false;
            this.isRotating = false;

            // Double-click detection (only for left button)
            this.lastClickTime = 0;
            this.doubleClickDelay = 300;
            
            // Middle button click detection
            this.middleClickStart = null;
            
            // Double-tap detection for mobile
            this.lastTapTime = 0;
            this.lastTapPos = null;
            this.doubleTapDelay = 300;
            this.doubleTapMaxDistance = 50;
            
            // Two-finger panning for mobile
            this.twoFingerPanStart = null;
            this.isTwoFingerPanning = false;

            // Fullscreen state
            this.isFullscreen = false;

            // Touch/pinch support
            this.touchStartDistance = 0;
            this.lastZoomLevel = 1;

            this.init();
        }

        init() {
            if (!this.container || !this.imageElement) {
                console.error('Rotator360: Container or image element not found');
                return;
            }
            this.preloadImages();
            this.setupEventListeners();
        }

        preloadImages() {
            let loadedCount = 0;
            const totalImages = this.totalFrames;
            for (let index = 0; index < totalImages; index++) {
                const frameNumber = this.startFrame + index;
                const imageUrl = this.getImageUrl(frameNumber);
                const img = new Image();
                if (!imageUrl) {
                    this.images.push(null);
                    continue;
                }
                img.src = imageUrl;
                img.onload = () => {
                    loadedCount++;
                    if (loadedCount === totalImages && this.overlay) {
                        this.overlay.classList.add('hidden');
                    }
                };
                img.onerror = () => {
                    loadedCount++;
                    if (loadedCount === totalImages && this.overlay) {
                        this.overlay.classList.add('hidden');
                    }
                };
                this.images.push(img);
            }
            this.updateImage(this.startFrame);
        }

        setupEventListeners() {
            this._handleStart = (e) => this.handleStart(e);
            this._handleMove = (e) => this.handleMove(e);
            this._handleEnd = (e) => this.handleEnd(e);
            this._handleWheel = (e) => this.handleWheel(e);

            this.container.addEventListener('mousedown', this._handleStart);
            document.addEventListener('mousemove', this._handleMove);
            document.addEventListener('mouseup', this._handleEnd);
            this.container.addEventListener('touchstart', this._handleStart, { passive: false });
            document.addEventListener('touchmove', this._handleMove, { passive: false });
            document.addEventListener('touchend', this._handleEnd);
            this.container.addEventListener('contextmenu', (e) => e.preventDefault());
            this.container.addEventListener('wheel', this._handleWheel, { passive: false });

            // Fullscreen change event
            document.addEventListener('fullscreenchange', () => this.handleFullscreenChange());
            document.addEventListener('webkitfullscreenchange', () => this.handleFullscreenChange());
            document.addEventListener('mozfullscreenchange', () => this.handleFullscreenChange());
            document.addEventListener('MSFullscreenChange', () => this.handleFullscreenChange());
        }


        handleStart(e) {
            this.cancelMomentum();
            const isTouch = !!e.touches;
            
            // Handle 2-finger touch for pinch-to-zoom and panning
            if (isTouch && e.touches.length === 2) {
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                this.touchStartDistance = Math.hypot(
                    touch2.clientX - touch1.clientX,
                    touch2.clientY - touch1.clientY
                );
                this.lastZoomLevel = this.zoomLevel;
                
                // Store center point for 2-finger panning
                const centerX = (touch1.clientX + touch2.clientX) / 2;
                const centerY = (touch1.clientY + touch2.clientY) / 2;
                this.twoFingerPanStart = { x: centerX, y: centerY };
                this.lastPanX = this.panX;
                this.lastPanY = this.panY;
                this.isTwoFingerPanning = false;
                
                e.preventDefault();
                return;
            }

            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            
            // Determine mode based on mouse button
            // Left button (0) or touch = rotation
            // Middle button (1) = reset (single click) or panning (drag)
            const button = isTouch ? 0 : e.button;
            const currentTime = performance.now();
            
            // Middle button - single click for reset
            if (button === 1) {
                this.isPanning = true;
                this.isRotating = false;
                this.middleClickStart = { x: clientX, y: clientY, time: currentTime };
                this.startX = clientX;
                this.startY = clientY;
                this.lastPanX = this.panX;
                this.lastPanY = this.panY;
                this.container.style.cursor = 'grabbing';
                e.preventDefault();
                return;
            }
            
            // Left button - double-click detection for fullscreen
            if (button === 0 && !isTouch && currentTime - this.lastClickTime < this.doubleClickDelay) {
                this.toggleFullscreen();
                this.lastClickTime = 0;
                e.preventDefault();
                return;
            }
            
            this.lastClickTime = currentTime;
            
            if (button === 0) {
                // Left button or touch - rotation mode
                this.isRotating = true;
                this.isPanning = false;
                this.isDragging = true;
                this.startX = clientX;
                this.lastX = clientX;
                this.lastMoveTs = performance.now();
                this.container.style.cursor = 'grabbing';
            }
            e.preventDefault();
        }

        handleMove(e) {
            const isTouch = !!e.touches;
            
            // Handle 2-finger touch: pinch-to-zoom and panning
            if (isTouch && e.touches.length === 2) {
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                const currentDistance = Math.hypot(
                    touch2.clientX - touch1.clientX,
                    touch2.clientY - touch1.clientY
                );
                
                // Calculate center point for panning
                const centerX = (touch1.clientX + touch2.clientX) / 2;
                const centerY = (touch1.clientY + touch2.clientY) / 2;
                
                if (this.touchStartDistance > 0 && this.twoFingerPanStart) {
                    // Calculate distance change (for zoom)
                    const distanceChange = Math.abs(currentDistance - this.touchStartDistance);
                    const distanceChangePercent = distanceChange / this.touchStartDistance;
                    
                    // Calculate center movement (for pan)
                    const centerDeltaX = centerX - this.twoFingerPanStart.x;
                    const centerDeltaY = centerY - this.twoFingerPanStart.y;
                    const centerMovement = Math.hypot(centerDeltaX, centerDeltaY);
                    
                    // Determine if it's a pinch (zoom) or pan based on movement
                    // If distance changes more than 5%, it's a pinch
                    if (distanceChangePercent > 0.05 || !this.isTwoFingerPanning) {
                        // Pinch-to-zoom
                        const scale = currentDistance / this.touchStartDistance;
                        let newZoom = this.lastZoomLevel * scale;
                        newZoom = Math.max(this.minZoom, Math.min(this.maxZoom, newZoom));
                        this.zoomLevel = newZoom;
                        
                        if (this.zoomLevel <= 1) {
                            this.panX = 0;
                            this.panY = 0;
                            this.twoFingerPanStart = { x: centerX, y: centerY };
                            this.lastPanX = 0;
                            this.lastPanY = 0;
                        }
                        
                        // If center moved significantly while pinching, also pan
                        if (centerMovement > 10) {
                            this.isTwoFingerPanning = true;
                            this.panX = this.lastPanX + centerDeltaX;
                            this.panY = this.lastPanY + centerDeltaY;
                        }
                    } else if (centerMovement > 5) {
                        // Two-finger panning (distance stays same, center moves)
                        this.isTwoFingerPanning = true;
                        this.panX = this.lastPanX + centerDeltaX;
                        this.panY = this.lastPanY + centerDeltaY;
                    }
                    
                    this.applyTransform();
                }
                e.preventDefault();
                return;
            }
            
            if (!this.isDragging && !this.isPanning) return;
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            
            if (this.isPanning) {
                // Panning mode (middle button on desktop)
                const deltaX = clientX - this.startX;
                const deltaY = clientY - this.startY;
                this.panX = this.lastPanX + deltaX;
                this.panY = this.lastPanY + deltaY;
                this.applyTransform();
            } else {
                // Normal rotation mode
                const deltaX = clientX - this.lastX;
                const now = performance.now();
                const dt = Math.max(1, now - this.lastMoveTs);
                this.velocityX = deltaX / dt;
                this.lastMoveTs = now;

                this.lastX = clientX;
                const sensitivity = 0.5;
                this.rotation += deltaX * sensitivity;
                this.updateFrameFromRotation();
            }
            e.preventDefault();
        }

        handleEnd(e) {
            const isTouch = e.changedTouches && e.changedTouches.length > 0;
            
            // Reset 2-finger touch state
            if (e.touches && e.touches.length < 2) {
                this.touchStartDistance = 0;
                this.twoFingerPanStart = null;
                this.isTwoFingerPanning = false;
            }
            
            // Double-tap detection for mobile (single finger only)
            if (isTouch && e.changedTouches.length === 1 && !this.isTwoFingerPanning) {
                const touch = e.changedTouches[0];
                const currentTime = performance.now();
                const tapPos = { x: touch.clientX, y: touch.clientY };
                
                if (this.lastTapTime && this.lastTapPos) {
                    const timeDiff = currentTime - this.lastTapTime;
                    const distance = Math.hypot(tapPos.x - this.lastTapPos.x, tapPos.y - this.lastTapPos.y);
                    
                    // Check if it's a double-tap (within time and distance thresholds)
                    if (timeDiff < this.doubleTapDelay && distance < this.doubleTapMaxDistance) {
                        // Double-tap detected - reset position
                        this.resetPosition();
                        this.lastTapTime = 0;
                        this.lastTapPos = null;
                        
                        // Prevent any drag/momentum
                        this.isDragging = false;
                        this.isPanning = false;
                        this.cancelMomentum();
                        return;
                    }
                }
                
                // Store this tap for next comparison
                this.lastTapTime = currentTime;
                this.lastTapPos = tapPos;
            }
            
            if (this.isPanning) {
                // Check if middle button was clicked without much movement (single-click reset)
                if (this.middleClickStart) {
                    const currentTime = performance.now();
                    const timeDiff = currentTime - this.middleClickStart.time;
                    const movement = Math.hypot(
                        (e.clientX || this.startX) - this.middleClickStart.x,
                        (e.clientY || this.startY) - this.middleClickStart.y
                    );
                    
                    // If clicked quickly (< 200ms) and didn't move much (< 5px), treat as reset
                    if (timeDiff < 200 && movement < 5) {
                        this.resetPosition();
                    }
                    this.middleClickStart = null;
                }
                
                this.isPanning = false;
                this.container.style.cursor = 'grab';
            } else if (this.isDragging) {
                this.isDragging = false;
                this.container.style.cursor = 'grab';
                this.applyMomentum();
            }
        }

        handleWheel(e) {
            e.preventDefault();
            const delta = e.deltaY;
            const zoomSensitivity = 0.001;
            const zoomChange = -delta * zoomSensitivity;
            
            let newZoom = this.zoomLevel + zoomChange;
            newZoom = Math.max(this.minZoom, Math.min(this.maxZoom, newZoom));
            
            if (newZoom !== this.zoomLevel) {
                this.zoomLevel = newZoom;
                // Reset pan when zooming out to level 1 or below
                if (this.zoomLevel <= 1) {
                    this.panX = 0;
                    this.panY = 0;
                }
                this.applyTransform();
            }
        }

        applyMomentum() {
            const sensitivity = 0.5;
            let vx = this.velocityX;
            const decay = 0.95;
            const minAbs = 0.0015;
            const step = () => {
                vx *= decay;
                if (Math.abs(vx) < minAbs) {
                    this.momentumId = 0;
                    return;
                }
                const px = vx * 16;
                this.rotation += px * sensitivity;
                this.updateFrameFromRotation();
                this.momentumId = requestAnimationFrame(step);
            };
            this.momentumId = requestAnimationFrame(step);
        }

        cancelMomentum() {
            if (this.momentumId) {
                cancelAnimationFrame(this.momentumId);
                this.momentumId = 0;
            }
        }

        updateFrameFromRotation() {
            const normalizedRotation = ((this.rotation % 360) + 360) % 360;
            const frameIndex = Math.round((normalizedRotation / 360) * this.totalFrames);
            let targetFrame = (frameIndex % this.totalFrames) + this.startFrame;
            if (targetFrame >= this.startFrame + this.totalFrames) {
                targetFrame = this.startFrame;
            }
            if (targetFrame !== this.currentFrame) {
                this.currentFrame = targetFrame;
                this.updateImage(targetFrame);
            }
        }

        updateImage(frameNumber) {
            const minFrame = this.startFrame;
            const maxFrame = this.startFrame + this.totalFrames - 1;
            if (frameNumber < minFrame || frameNumber > maxFrame) return;
            const imageUrl = this.getImageUrl(frameNumber);
            const arrayIndex = frameNumber - this.startFrame;
            const preloadedImg = this.images[arrayIndex];
            if (preloadedImg && preloadedImg.complete) {
                this.imageElement.src = preloadedImg.src;
            } else if (imageUrl) {
                this.imageElement.src = imageUrl;
            }
        }


        getImageUrl(frameNumber) {
            if (this.usesFrameUrls) {
                const index = frameNumber - this.startFrame;
                return this.frameUrls && this.frameUrls[index] ? this.frameUrls[index] : null;
            }
            const frameNum = String(frameNumber).padStart(this.framePadding, '0');
            const separator = this.useUnderscore ? '_' : '';
            return `${this.imagePath}${separator}${frameNum}.${this.imageFormat}`;
        }



        applyTransform() {
            if (!this.imageElement) return;
            const transform = `scale(${this.zoomLevel}) translate(${this.panX / this.zoomLevel}px, ${this.panY / this.zoomLevel}px)`;
            this.imageElement.style.transform = transform;
        }

        toggleFullscreen() {
            if (!this.isFullscreen) {
                // Enter fullscreen
                const elem = this.container;
                if (elem.requestFullscreen) {
                    elem.requestFullscreen();
                } else if (elem.webkitRequestFullscreen) {
                    elem.webkitRequestFullscreen();
                } else if (elem.mozRequestFullScreen) {
                    elem.mozRequestFullScreen();
                } else if (elem.msRequestFullscreen) {
                    elem.msRequestFullscreen();
                } else {
                    // Fallback for browsers that don't support fullscreen API
                    elem.classList.add('fullscreen');
                    this.isFullscreen = true;
                }
            } else {
                // Exit fullscreen
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                } else if (document.mozCancelFullScreen) {
                    document.mozCancelFullScreen();
                } else if (document.msExitFullscreen) {
                    document.msExitFullscreen();
                } else {
                    // Fallback
                    this.container.classList.remove('fullscreen');
                    this.isFullscreen = false;
                }
            }
        }

        handleFullscreenChange() {
            const isCurrentlyFullscreen = !!(document.fullscreenElement || 
                                             document.webkitFullscreenElement || 
                                             document.mozFullScreenElement || 
                                             document.msFullscreenElement);
            
            if (isCurrentlyFullscreen) {
                this.container.classList.add('fullscreen');
                this.isFullscreen = true;
            } else {
                this.container.classList.remove('fullscreen');
                this.isFullscreen = false;
            }
        }

        resetPosition() {
            // Stop all ongoing interactions
            this.cancelMomentum();
            this.isDragging = false;
            this.isPanning = false;
            this.isRotating = false;
            this.touchStartDistance = 0;
            
            // Reset all transformations
            this.rotation = 0;
            this.currentFrame = this.startFrame;
            this.zoomLevel = 1;
            this.panX = 0;
            this.panY = 0;
            this.velocityX = 0;
            
            // Update display
            this.updateImage(this.startFrame);
            this.applyTransform();
            this.container.style.cursor = 'grab';
        }

        destroy() {
            this.cancelMomentum();
            if (this.container) {
                document.removeEventListener('mousemove', this._handleMove);
                document.removeEventListener('mouseup', this._handleEnd);
                document.removeEventListener('touchmove', this._handleMove);
                document.removeEventListener('touchend', this._handleEnd);
            }
        }
    }

    // =========================
    // CONFIGURATION - ABBEY PRODUCT
    // =========================
    const CONFIG = {
        imagePath: 'https://raw.githubusercontent.com/healka/rotator-assets/main/Abbey001/',
        imageFormat: 'png',
        totalFrames: 72,
        startFrame: 0,
        framePadding: 5,
        useUnderscore: false,
        autoRotateSpeed: 0.5
    };

    // Initialize ONLY this rotator instance
    function initRotators() {
        const wrappers = document.querySelectorAll('.rotator-abbey');
        window.rotators = window.rotators || [];
        
        wrappers.forEach((wrapper) => {
            if (wrapper.dataset.rotatorInit) return;
            wrapper.dataset.rotatorInit = 'true';
            
            const instance = new Rotator360Embed(wrapper, CONFIG);
            window.rotators.push(instance);
        });
    }

    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initRotators);
    } else {
        initRotators();
    }
})();
</script>

